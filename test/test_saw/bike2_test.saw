include "llvm.saw";

import "bike2_test.cry";

// Prior to running the verification be sure to have all the valid files. 
// These include the .bc/.saw/.c/.cry

print "Loading the bike2_test bit code";
bike2_test_bc <- llvm_load_module "bike2_test.bc";

print "Extracting C reference term: addNums";
addNums <- llvm_extract bike2_test_bc "addNums";

print "Proving equivalence (C == Cryptol): addNums == add";
let thm1 = {{ \x -> \y -> addNums x y == add x y}};
result <- prove z3 thm1;
print result;

// Specify the binary polynomial modular addition function. 
print "Creating specification of C function: modAdd";
let modAdd_spec = do {

    // Allocate memory for each ptr parameter. FRESH is used for symbolic verification. 
    dst <- alloc WRITE i8 "dst" FRESH;
    a <- alloc CONST i8 "a" FRESH;
    b <- alloc CONST i8 "b" FRESH;
    
    // Execute the function.
    execute [dst.p, a.p, b.p];

    let (dst_t, a_t, b_t) = (dst.t, a.t, b.t);
    points_to dst.p (from_cryptol {{modAdd a_t b_t}});

};

modAdd_result <- llvm_verify bike2_test_bc "modAdd" [] modAdd_spec;

print "Done.";
