#include <stdio.h>
#include <stdint.h>
#include <stdbool.h> 
#include <string.h>

#define R_SIZE 1271

// Functions to test
uint32_t modAdd(const uint32_t *a, const uint32_t *b);
uint8_t modMult(const uint8_t *a, const uint8_t *b);
uint8_t polyMod(uint8_t *dst, const uint8_t *a, const uint32_t size);

int main ()
{
    // Testing the modAdd function
    const uint32_t bin1 = 0b00010110;
    const uint32_t bin2 = 0b00100011;  
    uint32_t sum = 0;
    sum = modAdd(&bin1, &bin2);
    printf("Testing modAdd: The two values (%#x, %#x) --> %#x\n", bin1, bin2, sum);

    // Testing the modMult and mod function
    const uint8_t bin_1 = 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016;
    const uint8_t bin_2 = 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023;
    uint8_t prod = modMult(&bin_1, &bin_2);
    printf("Testing modMult: The two values (%#x, %#x) --> %#x\n", bin_1, bin_2, prod);
    return 0;
}

// Bike Specific Functions
// Polynomial Modular Arithemetic Functions
uint32_t modAdd(const uint32_t *a, const uint32_t *b)
{
    return *a ^ *b;
}

uint8_t modMult(const uint8_t *x, const uint8_t *y)
{
    const uint32_t size = 1;
    uint8_t dst = 0;
    // Do not perform arithmetic on polynomial's a and b if they are NULL.
    if ((x != NULL) && (y != NULL))
    {
        uint8_t product[size * 2];
        memset(product, 0, size * 2); // zero out product
        for (uint32_t byteIndex = 0; byteIndex < size; byteIndex++)
        {
            for (uint32_t bitIndex = 0; bitIndex < 8; bitIndex++)
            {
                bool bit = x[byteIndex] & (0x01 << bitIndex);
                if (bit)
                {
                    for (uint32_t i = 0; i < size; i++)
                    {
                        uint16_t productPart = 0x0000;
                        productPart |= y[i] << bitIndex;
                        product[i + byteIndex] ^= (uint8_t)(productPart & 0x00FF);
                        product[i + byteIndex + 1] ^= (uint8_t)(productPart >> 8);
                    }
                }
            }
        }

        return polyMod(&dst, product, size * 2);
    }
    return 0;
}

// Note: dst is expected to be an array of length R_SIZE
uint8_t polyMod(uint8_t *dst, const uint8_t *a, const uint32_t size)
{
    // copy over the operand and it will be worked down to the remainder
    uint8_t remainder[size];
    memcpy(remainder, a, size);

    // loop down to the
    for (uint32_t i = size - 1; i >= R_SIZE; i--)
    {
        uint8_t bitMask = 0x01;
        while (remainder[i] != 0)
        {
            bool bit = remainder[i] & bitMask;

            if (bit)
            {
                remainder[i - R_SIZE] = remainder[i - R_SIZE] ^ bitMask;
            }

            remainder[i] = remainder[i] & (~bitMask);
            bitMask = bitMask << 1;
        }
    }

    memcpy(dst, remainder, (size / 2));
    return *dst;
}

